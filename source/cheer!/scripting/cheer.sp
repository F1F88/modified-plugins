#pragma semicolon 1
#pragma newdecls required

#include <sourcemod>
#include <colors>
#include <left4dhooks>
#include <sdktools>

#define PLUGIN_VERSION	   	"r2.1.2"

// Plugin definitions
public Plugin myinfo =
{
	name = "[L4D2] Cheer!",
	author = "dalto, blueblur",
	description = "The Cheer! plugin allows players to cheer random cheers per round",
	version	= PLUGIN_VERSION,
	url	= "https://github.com/blueblur0730/modified-plugins"
};

int
	g_iCheerCount[MAXPLAYERS + 1],
	g_iJeerCount[MAXPLAYERS + 1],
	g_iCurrentCheerChance[MAXPLAYERS + 1],
	g_iCurrentJeerChance[MAXPLAYERS + 1];

float
	g_fLastTimeCheer[MAXPLAYERS + 1],
	g_fLastTimeJeer[MAXPLAYERS + 1];

ConVar
	g_hCvarWayToPlay, g_hCvarRegainTime, g_hCvarMaxChance, g_hCvarCheerSoundDir, g_hCvarCheer, g_hCvarMaxCheers, 
	g_hCvarChat, g_hCvarJeerSoundDir, g_hCvarJeer, g_hCvarMaxJeers, g_hCvarJeerVolume,
	g_hCvarCheerVolume, g_hCvarCompetitiveEnable, g_hCvarDownloadEnable, g_hCvarCmdIntervalueEnable, g_hCvarCmdInterval;

int
	g_iCvarWayToPlay, g_iCvarMaxChance, g_iCvarMaxCheers, g_iCvarMaxJeers;
	
float
	g_fCvarRegainTime, g_fCvarJeerVolume, g_fCvarCheerVolume, g_fCvarCmdInterval;

bool
	g_bCvarCheer, g_bCvarChat, g_bCvarJeer, g_bCvarCompetitiveEnable, g_bCvarDownloadEnable, g_bCvarCmdIntervalueEnable;

char
	g_sCvarCheerSoundDir[PLATFORM_MAX_PATH], g_sCvarJeerSoundDir[PLATFORM_MAX_PATH];

ArrayList
	g_hArrayCheerFile, g_hArrayJeerFile;

bool
	g_bIsRoundAlive = false;

public void OnPluginStart()
{
	// ConVars
	CreateConVar("cheer_version", PLUGIN_VERSION, "Cheer Version", FCVAR_SPONLY | FCVAR_REPLICATED | FCVAR_NOTIFY);

	g_hCvarWayToPlay = CreateConVar("cheer_way_to_play", "2",
									 "The way to play sounds. \
									 1 = global chances is limited by cvars below, \
									 2 = global chance will regain with the time passing, which means global chance is only affected by these 3 cvars below.");
	g_hCvarRegainTime = CreateConVar("cheer_regain_time", "20.0", "The time to regain a chance to use command");
	g_hCvarMaxChance = CreateConVar("cheer_max_chance", "3", "Max chance to use command. The chance will regain");

	g_hCvarCheer = CreateConVar("cheer_enable", "1", "Enables the cheer");
	g_hCvarCheerSoundDir = CreateConVar("cheer_sound_dir", "nepu/cheer", "Sound file directory under the directory 'sound/...'");
	g_hCvarMaxCheers = CreateConVar("cheer_limit", "10", "The maximum number of cheers per round. This cvar is ignored if 'cheer_way_to_play' is set to 2 or 'cheer_competitive_mode_enable' is on");
	g_hCvarCheerVolume = CreateConVar("cheer_volume", "1.0", "Cheer volume: should be a number between 0.0. and 1.0");

	g_hCvarJeer	= CreateConVar("jeer_enable", "1", "Enables the jeer");
	g_hCvarJeerSoundDir = CreateConVar("jeer_sound_dir", "nepu/jeer", "Sound file directory under the directory 'sound/...'");
	g_hCvarMaxJeers	= CreateConVar("jeer_limit", "10", "The maximum number of jeers per round. This cvar is ignored if 'cheer_way_to_play' is set to 2 or 'cheer_competitive_mode_enable' is on");
	g_hCvarJeerVolume = CreateConVar("jeer_volume", "1.0", "Jeer volume: should be a number between 0.0. and 1.0");

	g_hCvarChat	= CreateConVar("cheer_chat", "1", "1 to turn enable chat messages, 0 for off");
	g_hCvarCmdIntervalueEnable = CreateConVar("cheer_cmd_interval_enable", "0", "Enable command interval? This cvar is ignored if 'cheer_competitive_mode_enable' is enabled");
	g_hCvarCmdInterval = CreateConVar("cheer_cmd_interval", "3.0", "Interval to cheer or jeer next time");
	g_hCvarCompetitiveEnable = CreateConVar("cheer_competitive_mode_enable", "0", "Enables the command in competitive mode when the round begins? This cvar is ignored if 'cheer_way_to_play' is set to 2");

	g_hCvarDownloadEnable = CreateConVar("cheer_download_enable", "0", "Enable download generated by Cheer! plugin ?");

	AddCvarChangeHook();
	SetCvar();
	InitIndex();

	// Cmd
	RegConsoleCmd("sm_cheer", CommandCheer);
	RegConsoleCmd("sm_jeer", CommandJeer);

	// Translations
	LoadTranslations("cheer.phrases");

	// Load Sounds
	g_hArrayCheerFile = new ArrayList(PLATFORM_MAX_PATH);
	g_hArrayJeerFile = new ArrayList(PLATFORM_MAX_PATH);
	LoadSounds();

	// Hooks
	HookEvent("round_start", Event_RoundStart, EventHookMode_PostNoCopy);
	HookEvent("round_end", Event_RoundEnd, EventHookMode_PostNoCopy);
	HookEvent("player_left_start_area", Event_PlayerLeftStartArea, EventHookMode_PostNoCopy);
}

void AddCvarChangeHook()
{
	g_hCvarWayToPlay.AddChangeHook(OnCvarChanged);
	g_hCvarRegainTime.AddChangeHook(OnCvarChanged);
	g_hCvarMaxChance.AddChangeHook(OnCvarChanged);
	g_hCvarCheerSoundDir.AddChangeHook(OnCvarChanged);
	g_hCvarCheer.AddChangeHook(OnCvarChanged);
	g_hCvarMaxCheers.AddChangeHook(OnCvarChanged);
	g_hCvarChat.AddChangeHook(OnCvarChanged);
	g_hCvarJeerSoundDir.AddChangeHook(OnCvarChanged);
	g_hCvarJeer.AddChangeHook(OnCvarChanged);
	g_hCvarMaxJeers.AddChangeHook(OnCvarChanged);
	g_hCvarJeerVolume.AddChangeHook(OnCvarChanged);
	g_hCvarCheerVolume.AddChangeHook(OnCvarChanged);
	g_hCvarCompetitiveEnable.AddChangeHook(OnCvarChanged);
	g_hCvarDownloadEnable.AddChangeHook(OnCvarChanged);
	g_hCvarCmdIntervalueEnable.AddChangeHook(OnCvarChanged);
	g_hCvarCmdInterval.AddChangeHook(OnCvarChanged);
}

public void OnCvarChanged(ConVar convar, const char[] oldValue, const char[] newValue)
{
	SetCvar();
}

void SetCvar()
{
	g_iCvarWayToPlay = g_hCvarWayToPlay.IntValue;
	g_iCvarMaxChance = g_hCvarMaxChance.IntValue;
	g_iCvarMaxCheers = g_hCvarMaxCheers.IntValue;
	g_iCvarMaxJeers = g_hCvarMaxJeers.IntValue;

	g_fCvarRegainTime = g_hCvarRegainTime.FloatValue;
	g_fCvarCheerVolume = g_hCvarCheerVolume.FloatValue;
	g_fCvarJeerVolume = g_hCvarJeerVolume.FloatValue;
	g_fCvarCmdInterval = g_hCvarCmdInterval.FloatValue;

	g_bCvarCheer = g_hCvarCheer.BoolValue;
	g_bCvarChat = g_hCvarChat.BoolValue;
	g_bCvarJeer = g_hCvarJeer.BoolValue;
	g_bCvarCompetitiveEnable = g_hCvarCompetitiveEnable.BoolValue;
	g_bCvarDownloadEnable = g_hCvarDownloadEnable.BoolValue;
	g_bCvarCmdIntervalueEnable = g_hCvarCmdIntervalueEnable.BoolValue;

	g_hCvarCheerSoundDir.GetString(g_sCvarCheerSoundDir, sizeof(g_sCvarCheerSoundDir));
	g_hCvarJeerSoundDir.GetString(g_sCvarJeerSoundDir, sizeof(g_sCvarJeerSoundDir));
}

public void OnMapStart()
{
	if (g_hArrayCheerFile.Length != 0)
		OnMapStart_Do(true);

	if (g_hArrayJeerFile.Length != 0)
		OnMapStart_Do(false);
}

void OnMapStart_Do(bool bCheerOrJeer)
{
	char sPath[PLATFORM_MAX_PATH];
	for (int i = 0; i < (bCheerOrJeer ? g_hArrayCheerFile.Length : g_hArrayJeerFile.Length); i++)
	{
		if (bCheerOrJeer)
		{
			if (g_hArrayCheerFile.GetString(i, sPath, sizeof(sPath)))
			{
				if (PrecacheSound(sPath, true))
					PrintToServer("[Cheer!] File %s precached successfully!", sPath);
			}
		}
		else
		{
			if (g_hArrayJeerFile.GetString(i, sPath, sizeof(sPath)))
			{
				if (PrecacheSound(sPath, true))
					PrintToServer("[Cheer!] File %s precached successfully!", sPath);
			}
		}

		if (g_bCvarDownloadEnable)
			AddFileToDownloadsTable(sPath);
	}
}

public void Event_PlayerLeftStartArea(Event event, char[] name, bool dontBroadcast)
{
	g_bIsRoundAlive = true;
}

// Initializations to be done at the beginning of the round
public void Event_RoundStart(Event event, char[] name, bool dontBroadcast)
{
	RestoreIndexes();
}

public void Event_RoundEnd(Event event, char[] name, bool dontBroadcast)
{
	RestoreIndexes();
}

// When a new client is put in the server we reset their cheer count
public void OnClientPutInServer(int client)
{
	if (client && !IsFakeClient(client))
	{
		g_iCheerCount[client] = 0;
		g_iJeerCount[client] = 0;
		g_fLastTimeCheer[client] = GetEngineTime();
		g_fLastTimeJeer[client] = GetEngineTime();
		g_iCurrentCheerChance[client] = g_iCvarMaxChance;
		g_iCurrentJeerChance[client] = g_iCvarMaxChance;
	}
}

void RestoreIndexes()
{
	SetIndex();
	g_bIsRoundAlive = false;
}

void InitIndex()
{
	SetIndex();
}

void SetIndex()
{
	for (int i = 0; i <= MaxClients; i++)
	{
		g_iCheerCount[i] = 0;
		g_iJeerCount[i]	= 0;
		g_fLastTimeCheer[i] = GetEngineTime();
		g_fLastTimeJeer[i] = GetEngineTime();
		g_iCurrentCheerChance[i] = g_iCvarMaxChance;
		g_iCurrentJeerChance[i] = g_iCvarMaxChance;
	}
}

// to pass the bool value we defined two functions here, this will make the code shorter.
Action CommandCheer(int client, int args)
{
	Command_CheerOrJeer(client, true);
	return Plugin_Handled;
}

Action CommandJeer(int client, int args)
{
	Command_CheerOrJeer(client, false);
	return Plugin_Handled;
}

void Command_CheerOrJeer(int client, bool bCheerOrJeer)
{
	if (!(bCheerOrJeer ? g_bCvarCheer : g_bCvarJeer))
	{
		CReplyToCommand(client, "%t", bCheerOrJeer ? "cheer_disabled" :"jeer_disabled");
		return;
	}

	if (!client || !IsClientInGame(client) || IsFakeClient(client))
		return;

	if (g_iCvarWayToPlay == 2)
	{
		if (bCheerOrJeer ? (g_iCurrentCheerChance[client] == 0) : (g_iCurrentJeerChance[client] == 0))
		{
			CPrintToChat(client, "%t", "Recharging");
			return;
		}
		else
		{
			ExcuteCheerOrJeer(bCheerOrJeer, client);
			return;
		}
	}

	if (g_bCvarCmdIntervalueEnable && g_iCvarWayToPlay == 1)
	{
		float fDelayTime = g_fCvarCmdInterval;

		if (bCheerOrJeer ? (g_iCheerCount[client] == 0) : (g_iJeerCount[client] == 0))
			g_fLastTimeCheer[client] = GetEngineTime();
		else
			g_fLastTimeJeer[client] = GetEngineTime();


		if (GetEngineTime() - (bCheerOrJeer ? g_fLastTimeCheer[client] : g_fLastTimeJeer[client]) < fDelayTime)
		{
			int iTimeLeft = RoundToNearest(fDelayTime - (GetEngineTime() - (bCheerOrJeer ? g_fLastTimeCheer[client] : g_fLastTimeJeer[client])));
			CPrintToChat(client, "%t", bCheerOrJeer ? "cheer_interval_limited" : "jeer_interval_limited", iTimeLeft);
			return;
		}
	}

	if (g_bCvarCompetitiveEnable && g_iCvarWayToPlay == 1)	
	{
		if (L4D_IsVersusMode() || L4D2_IsScavengeMode())
		{
			if (!g_bIsRoundAlive)
			{
				ExcuteCheerOrJeer(bCheerOrJeer, client);
				return;
			}
			else
			{
				CPrintToChat(client, "%t", "round_is_live");
				return;
			}
		}
	}

	if ((bCheerOrJeer ? (g_iCheerCount[client] >= g_iCvarMaxCheers) : (g_iJeerCount[client] >= g_iCvarMaxJeers)) && g_iCvarWayToPlay == 1)
	{
		CPrintToChat(client, "%t", bCheerOrJeer ? "over_cheer_limit" :"over_jeer_limit", bCheerOrJeer ? g_iCvarMaxCheers : g_iCvarMaxJeers);
		return;
	}
	else
	{
		ExcuteCheerOrJeer(bCheerOrJeer, client);
	}
}

void ExcuteCheerOrJeer(bool bCheerOrJeer, int client)
{
	char sBuffer[PLATFORM_MAX_PATH];
	if (bCheerOrJeer) g_hArrayCheerFile.GetString(GetRandomInt(0, g_hArrayCheerFile.Length - 1), sBuffer, PLATFORM_MAX_PATH);
	else g_hArrayJeerFile.GetString(GetRandomInt(0, g_hArrayCheerFile.Length - 1), sBuffer, PLATFORM_MAX_PATH);

	EmitSoundToAll(sBuffer, _, _, _, _, bCheerOrJeer ? g_fCvarCheerVolume : g_fCvarJeerVolume);

	if (g_bCvarChat)
	{
		char name[64];
		GetClientName(client, name, sizeof(name));
		CPrintToChatAllEx(client, "%t", bCheerOrJeer ? "Cheered!!!" : "Jeered!!!", name);
	}

	if (bCheerOrJeer) g_fLastTimeCheer[client] = GetEngineTime();
	else g_fLastTimeJeer[client] = GetEngineTime();
	 
	if (g_iCvarWayToPlay == 2) 
	{
		bCheerOrJeer ? g_iCurrentCheerChance[client]-- : g_iCurrentJeerChance[client]--;
		if ((bCheerOrJeer ? g_iCurrentCheerChance[client] : g_iCurrentJeerChance[client]) < g_iCvarMaxChance)
		{
			DataPack dp;
			CreateDataTimer(g_fCvarRegainTime, DPTimer_RegainChance, dp);
			dp.WriteCell(client);
			dp.WriteCell(bCheerOrJeer);
		}	
	}
	else bCheerOrJeer ? g_iCheerCount[client]++ : g_iJeerCount[client]++;
}

Action DPTimer_RegainChance(Handle Timer, DataPack dp)
{
	int client = dp.ReadCell();
	bool bCheerOrJeer = dp.ReadCell();
	bCheerOrJeer ? g_iCurrentCheerChance[client]++ : g_iCurrentJeerChance[client]++;
	return Plugin_Handled;
}

// from MapChanger by Alex Dragokas
void LoadSounds()
{
	DirectoryListing hDir;
	LoadSounds_Do(hDir, g_sCvarCheerSoundDir, true);
	LoadSounds_Do(hDir, g_sCvarJeerSoundDir, false);
	delete hDir;
}

void LoadSounds_Do(DirectoryListing hDir, char[] sPath, bool bCheerOrJeer)
{
	char sBuffer[PLATFORM_MAX_PATH];
	int iLen; char SoundFile[PLATFORM_MAX_PATH];
	FileType fileType;

	/**
	 * Note: When use OpenDirectory(), you need to specify concisely the folder in the base game dir.
	 * When use PrecacheSound() and EmitSound*(), the path string dose not need the prefix 'sound/',
	 * the function will automatically serch the file under the dir 'sound/' based on the path you put in.
	 */
	Format(sBuffer, PLATFORM_MAX_PATH, sPath);
	Format(sPath, PLATFORM_MAX_PATH, "sound/%s", sPath);
	hDir = OpenDirectory(sPath, false);
	if (hDir)
	{
		while (hDir.GetNext(SoundFile, PLATFORM_MAX_PATH, fileType))
		{
			if (fileType == FileType_File)
			{
				iLen = strlen(SoundFile);
				
				// maybe we should use .wav instead? issues with .mp3 really messed me up.
				if (iLen >= 4 && (strcmp(SoundFile[iLen - 4], ".mp3") == 0 || strcmp(SoundFile[iLen - 4], ".wav") == 0))
				{
					Format(SoundFile, sizeof(SoundFile), "%s/%s", sBuffer, SoundFile);
					if (bCheerOrJeer) g_hArrayCheerFile.PushString(SoundFile);
					else g_hArrayJeerFile.PushString(SoundFile);
				}
			}
		}
	}
	else
		PrintToServer("[Cheer!] handle 'hDir' is null! Please check your file path.");
}