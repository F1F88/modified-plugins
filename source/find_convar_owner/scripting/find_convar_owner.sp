/** changelog:
 * 1.0: 
 * 	- initial release.
 * 
 * 1.1: 
 * 	- fixed a problem when plugin name has the '/' slash character.
 * 	- fixed that there's only one cvar printed per plugin.
 * 
 *  * BUG: the number loopped through the function is totally not correct. But it dosen's affect the readability of the dumpped file.
*/

#pragma semicolon 1
#pragma newdecls required

#include <sourcemod>

#define PL_VERSION	"1.1"
#define DUMP_PATH	"data/dumpped_convars.txt"
#define DEBUG 0

enum struct ConVarInfo
{
	char PluginName[256];
	char cvar[256];
	// char flags[256];
	// char description[256];
}

bool	  g_bIsPluginLoaded = false, g_bIsConfigExecuted = false;
char	  g_sIgnorePath[PLATFORM_MAX_PATH];

ConVar g_hcvarHide, g_hcvarStoreNameType;

KeyValues kv;

ArrayList g_harrConVarName;

public Plugin myinfo =
{
	name = "[ANY] Find Convar Owner",
	author = "blueblur, basic method by Bacardi",
	description = "Finds the owner of convars generated by SourceMod. (A lite version of dump_all_cmds_cvars by Bacardi)",
	version = PL_VERSION,
	url = "https://github.com/blueblur0730/modified-plugins"
}

public void OnPluginStart()
{
	CreateConVar("find_convar_owner_version", PL_VERSION, "Version of the plugin.", FCVAR_NOTIFY | FCVAR_DONTRECORD | FCVAR_SPONLY);

	g_hcvarHide			 = CreateConVar("find_convar_owner_hide", "1", "hide the cvar of this plugin", _, true, 0.0, true, 1.0);
	g_hcvarStoreNameType = CreateConVar("find_convar_owner_storenametype", "2", "1 = File and path name, 2 = Descriptive name", _, true, 1.0, true, 2.0);

	RegServerCmd("sm_dumpcvar", Command_DumpCvar, "Dump");
	BuildPath(Path_SM, g_sIgnorePath, sizeof(g_sIgnorePath), DUMP_PATH);

	kv = new KeyValues("ConVars");
	g_harrConVarName = new ArrayList(sizeof(ConVarInfo));
}

public void OnAllPluginsLoaded()
{
	g_bIsPluginLoaded = true;
}

public void OnConfigsExecuted()
{
	g_bIsConfigExecuted = true;
}

public void OnMapEnd()
{
	g_bIsPluginLoaded	= false;
	g_bIsConfigExecuted = false;
}

Action Command_DumpCvar(int args)
{
	if (!g_bIsPluginLoaded || !g_bIsConfigExecuted)
	{
		PrintToServer("Plugin is not loaded or config is not executed yet.");
		return Plugin_Handled;
	}

	PrintToServer("Dumpping convars...");
	CollectConVars();

	return Plugin_Handled;
}

// from dump_all_cmds_cvars by Bacardi https://forums.alliedmods.net/showthread.php?p=2688799
void CollectConVars()
{
	char sBuffer[256];
	bool bIsCommand = false;
	int	flags = 0;
	char sDescription[256];
	Handle hConCmdIter;

	sBuffer[0]		= '\0';
	sDescription[0] = '\0';

	if (hConCmdIter == null)
	{
		hConCmdIter = FindFirstConCommand(sBuffer, sizeof(sBuffer), bIsCommand, flags, sDescription, sizeof(sDescription));

		if (hConCmdIter == null)
		{
			PrintToServer("No convars or cmds found.");
			return;
		}
	}

	bool bNext;

	do
	{
		if (sBuffer[0] != '\0' && !bIsCommand)
			StoreBuffers(sBuffer);
	}
	while ((bNext = FindNextConCommand(hConCmdIter, sBuffer, sizeof(sBuffer), bIsCommand, flags, sDescription, sizeof(sDescription))));

	if (!bNext)
		delete hConCmdIter;

	SetKvString();
	FinaleOutput();
}

/*
static const char g_sFlags[][] = {
	//"FCVAR_NONE",
	"FCVAR_UNREGISTERED", "FCVAR_DEVELOPMENTONLY", "FCVAR_GAMEDLL", "FCVAR_CLIENTDLL",
	//"FCVAR_MATERIAL_SYSTEM",
	"FCVAR_HIDDEN", "FCVAR_PROTECTED", "FCVAR_SPONLY", "FCVAR_ARCHIVE", "FCVAR_NOTIFY",
	"FCVAR_USERINFO", "FCVAR_PRINTABLEONLY", "FCVAR_UNLOGGED", "FCVAR_NEVER_AS_STRING",
	"FCVAR_REPLICATED", "FCVAR_CHEAT", "FCVAR_SS", "FCVAR_DEMO", "FCVAR_DONTRECORD",
	"FCVAR_SS_ADDED", "FCVAR_RELEASE", "FCVAR_RELOAD_MATERIALS", "FCVAR_RELOAD_TEXTURES",
	"FCVAR_NOT_CONNECTED", "FCVAR_MATERIAL_SYSTEM_THREAD",
	//"FCVAR_ARCHIVE_XBOX",
	"FCVAR_ARCHIVE_GAMECONSOLE", "FCVAR_ACCESSIBLE_FROM_THREADS", "", "", "FCVAR_SERVER_CAN_EXECUTE",
	"FCVAR_SERVER_CANNOT_QUERY", "FCVAR_CLIENTCMD_CAN_EXECUTE"
};
*/

void StoreBuffers(const char[] sBuffer)
{
	if (g_hcvarHide.BoolValue)
	{
		if (strcmp(sBuffer, "find_convar_owner_version") == 0
			|| strcmp(sBuffer, "find_convar_owner_hide") == 0
			|| strcmp(sBuffer, "find_convar_owner_storenametype") == 0)
			return;
	}

	if (kv == null)
		kv = new KeyValues("ConVars");

	if (g_harrConVarName == null)
		g_harrConVarName = new ArrayList(sizeof(ConVarInfo));

	ConVar hCvar = FindConVar(sBuffer);
	if (hCvar == null)
		return;

	char sPluginName[256];
	if (hCvar.Plugin != null)
	{
		if (g_hcvarStoreNameType.IntValue == 1)
			GetPluginFilename(hCvar.Plugin, sPluginName, sizeof(sPluginName));
		else
			GetPluginInfo(hCvar.Plugin, PlInfo_Name, sPluginName, sizeof(sPluginName));

		if (StrContains(sPluginName, "/") > -1)
			ReplaceString(sPluginName, sizeof(sPluginName), "/", "_");

		ConVarInfo sConVarInfo;
		sConVarInfo.PluginName = sPluginName;
		strcopy(sConVarInfo.cvar, sizeof(sConVarInfo.cvar), sBuffer);
		g_harrConVarName.PushArray(sConVarInfo);
/*
		strcopy(sConVarInfo.name, sizeof(sConVarInfo.name), sBuffer);

		strcopy(sConVarInfo.description, sizeof(sConVarInfo.description), sDescription);

		char sFlags[64];
		if (flags == 0)
			Format(sFlags, sizeof(sFlags), "FCVAR_NONE");
		else
		{
			for (int i = 0; i < sizeof(g_sFlags); i++)
			{
				if (flags & (1 << i))
					Format(sFlags, sizeof(sFlags), "%s | %s", sFlags, g_sFlags[i]);
			}
		}
		sConVarInfo.flags = sFlags;

		g_harrConVarName.PushArray(sConVarInfo);
*/
	}
}

/**
 * FIXME: there's an unsolved problem with kv.GoToNextKey() loop function. The keyvalue has already jumpped onto the key we need to check,
 * While there's no any other sub key under the current key, kv.GoToNextKey() should return false and integer a should no longer increase. but it dosen't.
 * I've checked it has nothing to do with arraylist nor enum struct, it's a pure keyvalue problem of kv.GoToNextKey() or kv.JumpToKey() function, or the speed of the loop maybe.
 * This problem finally cause the dumpped keyvalue file has a unregular sequence of cvar keys.
*/

void SetKvString()
{
	ConVarInfo sConVarInfo;
	char key[128];
	for (int i = 0; i < g_harrConVarName.Length; i++)
	{
		g_harrConVarName.GetArray(i, sConVarInfo);
		#if DEBUG
			PrintToServer("Plugin: %s, Cvar: %s", sConVarInfo.PluginName, sConVarInfo.cvar);
		#endif
		if (kv.JumpToKey(sConVarInfo.PluginName, true))
		{
			#if DEBUG
				PrintToServer("jumping to: %s", sConVarInfo.PluginName);
			#endif
					
			int a = 0;
			while (kv.GotoNextKey())
			{
				a += 1;
				#if DEBUG
					PrintToServer("time we loopped: %d", a);
				#endif
			}

			kv.Rewind();
			Format(key, sizeof(key), "%s/cvar%d", sConVarInfo.PluginName, a);
			kv.SetString(key, sConVarInfo.cvar);
		}
		kv.Rewind();
	}
}

void FinaleOutput()
{
	char sDumpPath[PLATFORM_MAX_PATH];
	BuildPath(Path_SM, sDumpPath, sizeof(sDumpPath), DUMP_PATH);
	kv.Rewind();
	kv.ExportToFile(sDumpPath);
	PrintToServer("Dumpping completed.");
	delete kv;
	delete g_harrConVarName;
}
