"Games"
{
	"left4dead2"
	{
		"Functions"
		{
			"CDirectorScavengeMode::OnStartIntro"
			{
				"signature"		"CDirectorScavengeMode::OnStartIntro"
				"callconv"		"thiscall"
				"return"		"int"
				"this"			"ignore"
			}

			"CDirector::AreBossesProhibited"
			{
				"signature"		"CDirector::AreBossesProhibited"
				"windows"
				{
					"callconv"		"stdcall"
				}
				"linux"
				{
					"callconv"		"cdecl"
				}
				"return"		"bool"
				"this"			"ignore"
				"arguments"
				{
					"prohibitbosses"
					{
						"type"		"bool"
					}
				}
			}

			"CDirectorScavengeMode::OnBeginRoundSetupTime"
			{
				"signature"		"CDirectorScavengeMode::OnBeginRoundSetupTime"
				"callconv"		"thiscall" // https://reverseengineering.stackexchange.com/questions/13703/what-is-byte-usercall-eax-and-edi
				"return"		"int"
				"this"			"ignore"
			}

			"CDirectorScavengeMode::OnEndOvertime"
			{
				"signature"		"CDirectorScavengeMode::OnEndOvertime"
				"callconv"		"thiscall"
				"return"		"void"
				"this"			"ignore"
			}
		}
		"Signatures"
		{
			//////////////
			// Detours
			//////////////
			"CDirectorScavengeMode::OnStartIntro"
			{
				"library"	"server"
				"linux"		"@_ZN21CDirectorScavengeMode12OnStartIntroEv"
				"windows"	"\x55\x8B\xEC\x83\xEC\x10\x56\x8B\xF1\xE8\x2A\x2A\x2A\x2A\x84\xC0\x74\x2A\xF3\x0F\x10\x46\x18"
							/* 55 8B EC 83 EC 10 56 8B F1 E8 ? ? ? ? 84 C0 74 ? F3 0F 10 46 18  */
							// search for string "ready_countdown", find all occurance, the 4th should be it.
							
			}

			// no unique symbols or offsets are found, abandoned.

			// char __usercall CDirectorScavengeMode::OnFinishIntro@<al>(long double@<st0>, CDirectorScavengeMode *this)
			//"CDirectorScavengeMode::OnFinishIntro"
			//{
			//	"library"	"server"
			//	"linux"		"@_ZN21CDirectorScavengeMode13OnFinishIntroEv"
			//	"windows"	""
			//}

			// could use  instead.

			// int CDirectorScavengeMode::OnEndRoundSetupTime()
			//"CDirectorScavengeMode::OnEndRoundSetupTime"
			//{
			//	"library"	"server"
			//	"linux"		"@_ZN21CDirectorScavengeMode19OnEndRoundSetupTimeEv"
			//	"windows"	"\x55\x8B\xEC\x83\xEC\x10\x33\xC0\x88\x45\xF8\x89\x45\xFC\x8D\x45\xF0\x50\xC7\x45\xF0\xFF\xFF\xFF\xFF\xC7\x45\xF4\x2A\x2A\x2A\x2A\xE8\x2A\x2A\x2A\x2A\x83\xC4\x04"
			//				/* 55 8B EC 83 EC 10 33 C0 88 45 F8 89 45 FC 8D 45 F0 50 C7 45 F0 FF FF FF FF C7 45 F4 ? ? ? ? E8 ? ? ? ? 83 C4 04 */
			//				// search for string "ready_countdown", find all occurance, the 3rd call should be it.
			//}

			// https://hex-rays.com/blog/igors-tip-of-the-week-51-custom-calling-conventions/
			// int __usercall CDirectorScavengeMode::OnBeginRoundSetupTime@<eax>(long double a1@<st0>, CDirectorScavengeMode *this)
			"CDirectorScavengeMode::OnBeginRoundSetupTime"
			{
				"library"	"server"
				"linux"		"@_ZN21CDirectorScavengeMode21OnBeginRoundSetupTimeEv"
				"windows"	"\x55\x8B\xEC\x83\xEC\x18\xA1\x2A\x2A\x2A\x2A\xD9\x40\x2C"
							/* 55 8B EC 83 EC 18 A1 ? ? ? ? D9 40 2C */
							// search for string "ready_countdown", find all occurance, the 2nd should be it.
			}

			// void *__cdecl CDirectorScavengeMode::OnEndOvertime(CDirectorScavengeMode *this, bool a2)
			"CDirectorScavengeMode::OnEndOvertime"	// for OnStartOverTime, use event "begin_scavenge_overtime"
			{
				"library"	"server"	// why you putting down two same functions?
				"linux"		"@_ZN21CDirectorScavengeMode13OnEndOvertimeEb"
				"windows"	"\x55\x8B\xEC\x56\x8D\x71\x24"
							/* 55 8B EC 56 8D 71 24 */
							// search for string "info_director" and find all occurance.
			}
			
			// bool __cdecl CDirector::AreBossesProhibited(CDirectorVersusMode **this)
			"CDirector::AreBossesProhibited"
			{
				"library"	"server"
				"linux"		"@_ZNK9CDirector19AreBossesProhibitedEv"
				"windows"	"\x55\x8B\xEC\x51\x56\x8B\xF1\x8B\x8E\x48\x06\x00\x00\x8D\x45\xFF\x50\xE8\x2A\x2A\x2A\x2A\x84\xC0\x74\x2A\x8A\x45\xFF\x5E\x8B\xE5\x5D\xC3\x8B\x8E\x44\x06\x00\x00"		
							/* 55 8B EC 51 56 8B F1 8B 8E 48 06 00 00 8D 45 FF 50 E8 ? ? ? ? 84 C0 74 ? 8A 45 FF 5E 8B E5 5D C3 8B 8E 44 06 00 00 */
							// search for string "ProhibitBosses".
			}

			////////////////
			// Calls
			////////////////

			// int __cdecl CTerrorGameRules::TrackPlayerZombieDamage(CTerrorGameRules *this, CTerrorPlayer *, int, int)
			"CTerrorGameRules::TrackPlayerZombieDamage"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules23TrackPlayerZombieDamageEP13CTerrorPlayerib"
				"windows"	"\x55\x8B\xEC\x56\x8B\x75\x08\x57\x8B\xF9\x85\xF6\x74\x2A\x8B\x06\x8B\x90\x40\x05\x00\x00"
							/* 55 8B EC 56 8B 75 08 57 8B F9 85 F6 74 ? 8B 06 8B 90 40 05 00 00 */
							// find CTerrorGameRules::RecordInfectedDamageForVersus in left4dhooks, xref it and the first one shoulld be it
			}

			// int __cdecl CTerrorGameRules::IncrementScavengeMatchScore(CTerrorGameRules *this, int)
			"CTerrorGameRules::IncrementScavengeMatchScore"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules27IncrementScavengeMatchScoreEi"
				"windows"	"\x55\x8B\xEC\x53\x8B\x5D\x08\x57\x8B\xF9\x85\xDB\x7E\x2A\x56\x8B\xB4\x9F\xD4\x03\x00\x00"
							/* 55 8B EC 53 8B 5D 08 57 8B F9 85 DB 7E ? 56 8B B4 9F D4 03 00 00  */
							// find CDirectorScavengeMode::EndScavengeRound (description below), at the mid of the function,
							// notice "if ( !v4 )", statement inside calls CTerrorGameRules::IncrementScavengeMatchScore.
			}

			// int __usercall CDirectorScavengeMode::UpdateOvertimeState@<eax>(long double a1@<st0>, CDirectorScavengeMode *this)
			"CDirectorScavengeMode::UpdateOvertimeState"
			{
				"library"	"server"
				"linux"		"@_ZN21CDirectorScavengeMode19UpdateOvertimeStateEv"
				"windows"	"\x55\x8B\xEC\x51\x53\x56\x8D\x45\xFF"
							/* 55 8B EC 51 53 56 8D 45 FF */
							// find CDirectorScavengeMode::OnEndOvertime (description above), the only one xref should be it.
			}

			// int __cdecl CTerrorGameRules::ResetRoundNumber(CTerrorGameRules *this) this is called by CDirector::Rematch
			"CTerrorGameRules::ResetRoundNumber"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules16ResetRoundNumberEv"
				"windows"	"\x56\x8B\xF1\x83\xBE\x54\x04\x00\x00\x00"
							/* 56 8B F1 83 BE 54 04 00 00 00 */
							// find CDirector::Rematch by left4dhooks first, the 2nd function that passes the this pointer should be it.
			}

			// int __cdecl CTerrorGameRules::AccumulateTime(CTerrorGameRules *this, float a2)
			// int __userpurge sub_102DFBC0@<eax>(int a1@<ecx>, char a2@<efl>, float a3) windows
			"CTerrorGameRules::AccumulateTime"	// this add time to the scoreboard.
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules14AccumulateTimeEf"
				"windows"	"\x55\x8B\xEC\x56\x8B\xF1\xF3\x0F\x10\x8E\x50\x04\x00\x00"
							/* 55 8B EC 56 8B F1 F3 0F 10 8E 50 04 00 00 */
							// search for string "ScavengeRoundInitialTime" to find all occurance, the 1st one should be CDirectorScavengeMode::ResetNonVirtual
							// inside the function the return call should be it.
			}

			// int __usercall CDirectorScavengeMode::RestartScavengeRound@<eax>(long double a1@<st0>, CDirectorScavengeMode *this)
			"CDirectorScavengeMode::RestartScavengeRound"
			{
				"library"	"server"
				"linux"		"@_ZN21CDirectorScavengeMode20RestartScavengeRoundEv"
				"windows"	"\x56\x8B\xF1\x80\x3E\x00\x8B\x0D\x2A\x2A\x2A\x2A"
							/* 56 8B F1 80 3E 00 8B 0D ? ? ? ? */
							// search for string "Director::FinishScenarioExit\n", find CDirector::FinishScenarioExit
							// xref it the 5th function with text "jmp" should be it.
			}

			// bool CDirectorScavengeMode::UpdateScavengeMobSpawns()
			"CDirectorScavengeMode::UpdateScavengeMobSpawns"
			{
				"library"	"server"
				"linux"		"@_ZN21CDirectorScavengeMode23UpdateScavengeMobSpawnsEv"
				"windows"	"\xE8\x2A\x2A\x2A\x2A\x84\xC0\x75\x2A\xC3"
							/* E8 ? ? ? ? 84 C0 75 ? C3  */
							// search for either "Director::Update" (yes it's a string) "MobRechargeRate" "MobMaxSize" "WaterSlowsMovement" to find Director::Update
							// the 4th call that passes this pointer (right under CVProfile::ExitScope(g_VProfCurrentProfile);) should be CDirector::UpdateMobSpawns
							// inside of it, the 3rd call should be it. (by comparing the this pointer, the 2nd call is not the target we want, so left this one to be it.)
			}

			// void __cdecl CDirectorScavengeMode::EndScavengeRound(CDirectorScavengeMode *this)
			"CDirectorScavengeMode::EndScavengeRound" // dose the same as the command "scenario_end", but more directly
			{
				"library"	"server"
				"linux"		"@_ZN21CDirectorScavengeMode16EndScavengeRoundEv"
				"windows"	"\x55\x8B\xEC\x83\xEC\x10\x56\x8B\xF1\x80\x7E\x08\x00"
							/* 55 8B EC 83 EC 10 56 8B F1 80 7E 08 00  */
							// search either "scavenge_round_finished" "scavenge_match_finished" "scavenge_round_haltime" "ScavengeRoundInitialTime".
			}

			// CDirectorScavengeMode *__cdecl CDirector::IncrementScavengeTeamScore(CDirectorScavengeMode **this, int, CBaseEntity *)
			"CDirector::IncrementScavengeTeamScore"		// this increment score and add time to the scoreboard. (calls CDirectorScavengeMode::IncrementScavengeTeamScoreNonVirtual)
			{
				"library"	"server"
				"linux"		"@_ZN9CDirector26IncrementScavengeTeamScoreEiP11CBaseEntity"
				"windows"	"\x55\x8B\xEC\x56\x8B\xF1\xE8\x2A\x2A\x2A\x2A\x84\xC0\x74\x2A\x8B\x86\x44\x06\x00\x00"
							/* 55 8B EC 56 8B F1 E8 ? ? ? ? 84 C0 74 ? 8B 86 44 06 00 00 */
			}

			// void __cdecl CTerrorGameRules::IncrementScavengeTeamScore(CTerrorGameRules *this, int)
			"CTerrorGameRules::IncrementScavengeTeamScore"	// this only increment the score.
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules26IncrementScavengeTeamScoreEi"
				"windows"	"\x55\x8B\xEC\x8B\x45\x08\x57\x8B\xF9\x83\xF8\x02\x7C\x2A"
							/* 55 8B EC 8B 45 08 57 8B F9 83 F8 02 7C ?  */
							// find CGasCan::OnActionComplete by search string "gascan_pour_completed",
							// the 3rd call that pass the this pointer and constant value 2 and var a2 should be CDirecor::IncrementScavengeTeamScore,
							// inside it the second call should be it.
			}

			// int __cdecl CTerrorGameRules::GetScavengeScoreInternal(CTerrorGameRules *this, int a2, int a3)
			"CTerrorGameRules::GetScavengeScoreInternal"
			{
				"library"	"server"
				"linux"		"@_ZN16CTerrorGameRules24GetScavengeScoreInternalEii"
				"windows"	""
			}
		}
	}
}